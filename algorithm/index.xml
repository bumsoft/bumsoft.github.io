<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>writing on BumSoft</title>
    <link>https://bumsoft.github.io/algorithm/</link>
    <description>Recent content in writing on BumSoft</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Nov 2023 14:48:08 +0900</lastBuildDate><atom:link href="https://bumsoft.github.io/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dijkstra&#39;s algorithm</title>
      <link>https://bumsoft.github.io/algorithm/dijkstra/</link>
      <pubDate>Mon, 20 Nov 2023 16:05:08 +0900</pubDate>
      
      <guid>https://bumsoft.github.io/algorithm/dijkstra/</guid>
      <description>다익스트라 알고리즘은 하나의 정점 에서 다른 모든 정점으로 가는 최단 경로 탐색 알고리즘이다.
알고리즘에 대한 자세한 설명은 건너뛰고 구현위주로 작성하겠다.
벡터 배열 우선순위 큐 C++로 다익스트라 구현하기 위해 위 3가지가 필요하다.
우선 정점의 개수가 N개라고 가정을 하자.
벡터는 다음과 같이 선언할 것이다. (1번 정점부터 N번 정점까지 저장해야하기에 N+1) vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; vertex[N+1]; vertex[i] : i번 정점
vertex[i]의 원소 :pair( i에서 갈 수 있는 다른 정점 , 그 정점까지의 가중치 )
예를 들어 다음 그래프에서 vertex[1]과 vertex[2]의 원소는 다음과 같다.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 백준 7677 Fibonacci</title>
      <link>https://bumsoft.github.io/algorithm/7677/</link>
      <pubDate>Sun, 05 Nov 2023 04:06:08 +0900</pubDate>
      
      <guid>https://bumsoft.github.io/algorithm/7677/</guid>
      <description>문제 풀러가기 피보나치수를 구하는 문제였다.
다만 N의 최대가 1,000,000,000이라 예전에 dp로 풀었을 땐 시간초과가 났다.
이산수학에서 행렬을 배우고 다시 보니 풀 수 있을 것 같아서 다시 풀어봤다.
풀이 행렬의 거듭제곱을 이용해야한다. 다만, N번 곱한다면 시간복잡도가 O(N) 이기에 이문제는 풀 수 없다.
분할정복을 이용한 거듭제곱 알고리즘을 사용해 O(logN)으로 풀 수 있다. 분할정복을 이용한 거듭제곱
N이 짝수 A^N = A^(N/2) * A^(N/2)
N이 홀수 A^N = A^((N-1)/2) * A^((N-1)/2) * A
2*2라 그냥 2차원배열로 만들까 생각도 했지만 이번기회에 벡터사용에 익숙해지면 좋을 것 같아 벡터를 사용했다.</description>
    </item>
    
  </channel>
</rss>
